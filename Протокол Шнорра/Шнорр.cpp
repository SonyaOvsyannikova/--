/*Необходимо создать реализацию протокола доказательства с нулевым 
разглашением Шорра. В интерфейсе приложения должны быть наглядно 
представлены:
1. Исходные данные протокола (модули, ключи, секретные данные и 
т.п.);
2. Данные, передаваемые по сети каждой из сторон;
3. Проверки, выполняемые каждым из участников.*/

/*1. Выбирается два простых числа p и q, причём q|(p-1).
2. Выбирается число t (2^𝑡<𝑞), являющееся параметром безопасности.
3. Выбирается элемент g, лежащий в пределах (1, p-1) и имеющий 
порядок q.
4. Каждая сторона протокола получает копию системных параметров 
(g,p,q), а также открытый ключ доверенного центра T, который 
позволяет проверить подпись сообщения m.
Этап 2: Выработка параметров пользователя 
1. Каждая сторона протокола A получает уникальный идентификатор 
𝐼𝐴; 
2. Сторона A выбирает приватный ключ a (лежащий в пределах (1, q1)) и вычисляет 𝑣=𝑔
−𝑎(𝑚𝑜𝑑𝑝); 
3. Сторона A передаёт v доверенному центру T и получает сертификат 
𝑐𝑒𝑟𝑡𝐴=(𝐼𝐴,𝑣,𝑆𝑟(𝐼𝐴,𝑣)), который связывает v и 𝐼𝐴. 
Этап 3: Доказательство 
1. Доказывающая сторона A случайным образом выбирает число r 
(0<r<q), вычисляет 𝑥=𝑔𝑟(𝑚𝑜𝑑𝑝) и отправляет проверяющей стороне 
B (𝑐𝑒𝑟𝑡𝐴,𝑥); 
2. Сторона B делает вывод об аутентичности открытого ключа v 
доказывающей стороны A путём проверки подписи доверенного 
центра, после чего отправляет A случайное ранее не 
использовавшееся число e, 1≤𝑒≤2𝑡
; 
3. Сторона A проверяет 1≤𝑒≤2𝑡и передаёт B 𝑦=𝑎𝑒+𝑟 (𝑚𝑜𝑑𝑞); 
4. B вычисляет 𝑧=𝑔𝑦∙𝑣𝑒(𝑚𝑜𝑑𝑝) и принимает доказательство, если z=x. */

#include <iostream>
#include <math.h>
#include <time.h>
#include <random>
#include <vector>
#include <windows.h>
#include <iomanip>
using namespace std;

bool isPrime(int* n)
{
	// если n > 1
	if (*n > 1)
	{
		// в цикле перебираем числа от 2 до n - 1
		for (int i = 2; i < *n; i++)
		{
			if (*n % i == 0)
			{// если n делится без остатка на i - возвращаем false (число не простое)
				return false;
				break;
			}
		}


		// если программа дошла до данного оператора, то возвращаем true (число простое) - проверка пройдена
		return true;
	}
	else // иначе возвращаем false (число не простое)
		return false;
}

void Gen_prost(int* a)
{
	srand(time(NULL));
	*a = 1 + rand() % 700;
	while (isPrime(a) == false)
	{
		*a = 1 + rand() % 700;
	}

}

void showarr(vector <int>& a) // создаем массив 
{
	// cout << "[";
	for (int i = 0; i < a.size(); i++)
	{
		cout << a[i] << "    ";
	}
	// cout << "]";
}

void S_gen(int* n, int* s)
{

	*s = 1 + rand() % (*n - 1);

}
// тененбаун

/*Выбирается элемент g, лежащий в пределах (1, p-1) и имеющий 
порядок q.*/


/*Каждая сторона протокола получает копию системных параметров 
(g,p,q), а также открытый ключ доверенного центра T, который 
позволяет проверить подпись сообщения m.*/

void main()
{
	setlocale(LC_ALL, "ru");
	int p;
	int q;
	Gen_prost(&p);
	cout << "p = " << p << endl;
	Sleep(1000);
	Gen_prost(&q);
	cout << "q = " << q << endl << endl;

	int n = abs(p * q);
	cout << "n = " << n << endl << endl;

	int t;
	Gen_prost(&t);
	cout << "t = " << t << endl;
	int k;
	k = 2 ^ t;
	if (k > q)
	{
		cout << "продолжаем дальше по пунктам" << endl;
		system("pause");
	}
	else
	{
		Gen_prost(&t);
	}

	int g;
	Gen_prost(&g);
	cout << "g = " << g << endl;
	if (g > 1 && g < (p - 1))
	{
		cout << "продолжаем дальше по пунктам" << endl;
		g = q;
	}
	else
	{
		Gen_prost(&g);
	}



	int s;
	S_gen(&n, &s);
	int r;
	S_gen(&n, &r);

	int V;
	V = (s * s) % n;
	cout << "Открытый ключ V =  " << V << endl;

	int x;
	x = (r * r) % n;
	cout << "Открытый ключ x =  " << x << endl;

	cout << "случайно генерируем бит e 0 или 1" << endl;
	srand(time(NULL));
	int e;
	e = rand() % 2;
	cout << "сгенерированный бит " << e;
	cout << endl;
}
